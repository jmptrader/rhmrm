
RHMRM - RISCy Handmaid Multistack Register Machine Specification
Version 0.1.20


##### SUMMARY ##############################################################

+ 16 bit words
+ 32 general registers
+ 8  control registers
+ 0x10000 words of memory (131072 octets)


##### REGISTERS ############################################################

Conventional register purposes:

 ID      | DESCRIPTION         | NAME  | SAVER
---------+---------------------+-------+-------
 r0      | always zero         | zr    | n/a

 r1        return address        ra      caller
 r2-r9     saved registers       s0-s7   callee
 r10-r17   temporary registers   t0-t7   caller
 r18-r21   return values         v0-v3   caller
 r22-r29   function arguments    a0-a7   caller
 r30       frame pointer         fp      callee
 r31       stack pointer         sp      callee

 c0        program counter       pc      callee
 c1        extra                 ex      callee
 c2-c3     -- reserved --        --      n/a
 c4        interrupt vector      iv      callee
 c5-c7     -- reserved --        --      n/a

# C0 - PC
Points to the next instruction.

# C1 - EX
Set by most arithmeic and logical instructions, in most cases contains
higher 16 bits of the result.

# C4 - IV [IH-- ---n nnnn nnnn]
Contains a pointer to interrupt table, shifted right by 7 (n),
and the following interrupt flags:
+ I - if set, external interrupts are ignored.
+ H - if set, external interrupt happened.


##### OPCODES ##############################################################

 ID | OPERATOR | EFFECT                               | DESCRIPTION
 ---+----------+-----------                  ---------+---------
    |          |                                      |
 0 - Moving things:
 01 | mov a, b | Ra := Rb                               MOVe register
 02 | mtc k, b | Ck := Rb                               Move To Control
 03 | mfc a, k | Ra := Ck                               Move From Control
    |          |
 04 | str a, b | [Ra] := Rb                             SToRe
 05 | psh a, b | Ra := Ra - 1, [Ra] := Rb               PuSH
 06 | loa a, b | Ra := [Rb]                             LOAd
 07 | pop a, b | Ra := [Rb], Rb := Rb + 1               POP
    |          |
 1 - Arithmetic things:
 10 | add a, b | Ra := Ra + Rb                          ADD
 11 | adx a, b | Ra := Ra + Rb + EX                     ADd with EX
 12 | sub a, b | Ra := Ra - Rb                          SUBtract
 13 | sbx a, b | Ra := Ra - Rb + EX                     SUbtract with EX
 14 | mul a, b | Ra := Ra * Rb                          MULtiply
 15 | mli a, b | Ra := Ra * Rb                          MuLtiply sIgned
 16 | div a, b | Ra := Ra / Rb                          DIVide
 17 | dvi a, b | Ra := Ra / Rb                          DiVide sIgned
 18 | mod a, b | Ra := Ra % Rb                          MODulo
 19 | mdi a, b | Ra := Ra % Rb                          MoDulo sIgned
 1a | idc a, b | Ra := Ra + b                           Increment/DeCrement
    |          |
 2 - Logicing things:
 20 | and a, b | Ra := Ra & Rb                          logical AND
 21 | ior a, b | Ra := Ra | Rb                          Inclusive OR
 22 | xor a, b | Ra := Ra ^ Rb                          eXclusive OR
 23 | shl a, b | Ra := Ra << b                          SHift Left
 24 | asr a, b | Ra := Ra >> b                          Arithmetic Shift Right
 25 | shr a, b | Ra := Ra >> b                          SHift Right
 26 | rol a, b | Ra := (Ra << b) & (Ra >> (16 - b))     ROtate Left
 27 | ror a, b | Ra := (Ra >> b) & (Ra << (16 - b))     ROtate Right
    |          |
 28 | tst a, b | EX := (and a, b)                       TeST bits
 29 | teq a, b | EX := (xor a, b)                       Test bitwise EQuality
 2a | cmp a, b | EX := (sub a, b)                       CoMPare
 2b | cmn a, b | EX := (add a, b)                       ComPare Negative
    |          |
 3 - Jumping things:
 30 | jmp c    | PC := PC + c                           Jump Near
 31 | jle c    | EX < 0  ? (jpn c)                      Jump if LEsser
 32 | jng c    | EX <= 0 ? (jpn c)                      Jump if Not Greater
 33 | jgr c    | EX > 0  ? (jpn c)                      Jump if GReater
 34 | jnl c    | EX >= 0 ? (jpn c)                      Jump if Not Lesser
 35 | jeq c    | EX == 0 ? (jpn c)                      Jump if EQual
 36 | jne c    | EX != 0 ? (jpn c)                      Jump if Not Equal
    |          |
 3b | swi c    | trigger software interrupt c           SoftWare Interrupt
 3c | hwi c    | trigger hardware interrupt c           HardWare Interrupt
 3d | sim c    | set interrupt mode with vector at c    Set Interrupt Mode
    |          |
 3E - Weird thing:
 3e | set a, b, n, m   | Ra := n, Rb := m, PC := PC + 2 SET
 3e | jsc b, n         | Rb := PC + 1, PC := n          Jump Saving Counter
 3e | spc n            | PC := n                        Set PC


##### INSTRUCTIONS #########################################################

Each instruction (except SET) is 16 bit word.

For arithmetic operators:
ADD, ADX, SUB, SBX, MUL, MLI and SHL set EX to higher 16 bits of the result.
DIV, DVI, ASR and SHR set EX to lower 16 bits of the result.

DIV and DVI set Ra to 0xffff and -1 respectively when divisor equals zero.
MOD and MDI set Ra to Rb when divisor equals zero.


In opcode descriptions:

+ Opcode mnemonic corresponds to bits [6:0] of instruction;

+ a and b hold 5-bit register indices (in range [0,31]);
+ a corresponds to bits [9:5] of instruction;
+ a corresponds to bits [15:10] of instruction;

+ k in MTC and MFC instructions is a 5 bit field consisting of register
  index in bits [2:0] and access mode in bits [4:3], which can one of:
  * 00 - SET
  * 01 - AND
  * 10 - IOR
  * 11 - XOR

+ c holds 10-bit value, signed for conditional jumps, unsigned for
  interrupt instruction;
+ c corresponds to bits [15:5] of instruction;

+ SIM sets I flag to the sign bit of an operand, setting IV register to
  (c & 0x1ff) << 7

+ n1 and n2 in SET instruction are 16-bit words at [PC+1] and [PC+2];
+ JSP instruction is a special case of SET with a = 0;
+ SPC instruction is a special case of SET with a and b equal 0.


For instruction '<3e> a, b':
+ if neither a nor b is r0, set Ra to a next word, set Rb to a word after
  next and increment PC by 3;
+ if b is r0, set Ra to a next word, then increment PC by 2;
+ if a is r0, set Rb to PC, then set PC to a next word, then
  increment PC by 2.


############################################################################

;;;; Example

:start  set a0, 9
        jsc fib, ra         ;; fib(9)
        spc crash

:fib    set v0, t0, 0, 1    ;; curr := 0, next := 1
        set t7, 1
:.loop  sub a0, t7
        jng .ret
        mov t1, t0          ;; temp := curr + next
        add t1, v0
        mov v0, t0          ;; curr := next
        mov t0, t1          ;; nect := temp
        jmp .loop
:.ret   spc ra              ;; return

:crash  jmp -1
